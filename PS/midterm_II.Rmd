
---
title: "Midterm II"
author: "WRITE YOUR NAME HERE"
date: "Last updated on `r Sys.Date()`"
output:
  html_document:
    df_print: kable
---



```{r, echo=TRUE, message=FALSE}
library(ggplot2)
library(dplyr)
library(knitr)
library(readr)
```



## Question 1: Women and Children First

**Research question**: Did the "women-and-children" first
policy hold? Hint: the answer is yes.

Argue your conclusion using the results from an outputed table. Do as much as
you can computationally to minimize the number of hand calculations you may need
to make (if any).

```{r, message=FALSE, echo=TRUE}
data(Titanic)
# Convert Titanic data to tidy format
Titanic <- Titanic %>% 
  as.data.frame()

Titanic %>% 
  group_by(Survived, Sex, Age) %>% 
  summarise(Freq=sum(Freq)) 
```


**Conclusion**: 

* `338/(338+1329)` = 20.3% of male adults survived
* `(29+28+316)/(29+28+316+35+17+109)` = 69.8% of everyone else survived

Don't need no PhD in statistics to know this difference is **statistically significant** i.e.

1. Survival wasn't random
1. There was a mechanism dictating who had greater chances of survival







## Question 2: America Runs on Starbucks?

**Research question**: Do Starbucks tend to locate in higher income neighbors,
while Dunkin Donuts does not i.e. they tend to locate in lower income
neighborhoods." 

**Your conclusion**: Here is the plot from the midterm (without colors).

```{r, message=FALSE, echo=TRUE, warning=FALSE, fig.width=16/2, fig.height=9/2}
DD_vs_SB <- read_csv("https://raw.githubusercontent.com/rudeboybert/MATH116/gh-pages/assets/data/DD_vs_SB.csv")

ggplot(DD_vs_SB, aes(x=median_income, y=shops_per_1000)) +
  geom_point() + 
  facet_wrap(~Type) +
  geom_smooth(method="lm", se=FALSE) + 
  labs(x="Median Household Income", y="# per 1000 people", title="Coffee/Cafe Comparison in Eastern MA")
```

I'm going to do three things to improve it:

* Use a smoother that isn't a regression line
* Change the y-axis scale to where most of the points are: between 0 and 0.75
* Use `alpha=0.1` in the `geom_point()` to try to see better what's going on at `y=0`

```{r, message=FALSE, echo=TRUE, warning=FALSE, fig.width=16/2, fig.height=9/2}
ggplot(DD_vs_SB, aes(x=median_income, y=shops_per_1000)) +
  geom_point(alpha=0.1) + 
  facet_wrap(~Type) +
  geom_smooth(se=FALSE) + 
  labs(x="Median Household Income", y="# per 1000 people", title="Coffee/Cafe Comparison in Eastern MA") +
  coord_cartesian(ylim=c(0, 0.75))
```

**Advanced**: Why did I use `coord_cartesian(ylim=c(0, 0.75))` and not 
`ylim(c(0, 0.75))`? Because of **point clipping**. See the [ggplot2 
cheatsheet](https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf),
back page, bottom right corner, Zooming section to see the difference in
behavior. Some times you want to "clip" points and others you don't. 

In our case, if you clip points, it will alter the behavior of the smoother
since it will be based on fewer points. This also relevant to Question 3.d)
below.





## Question 3: NYC Flights

```{r, message=FALSE, echo=TRUE}
library(nycflights13)
data(airports)
data(planes)
data(flights)
data(weather)
data(airlines)
```



#### c)

Write the rough pseudocode that will output a table presenting the median
departure delay of all flights for each airline leaving Newark (airport code
`EWR`) in reverse alphabetical order.

**Solution**: This gets the job done:

```{r, message=FALSE, echo=TRUE}
median_delays_by_carrier_EWR <- flights %>% 
  filter(origin == "EWR") %>% 
  group_by(carrier) %>% 
  summarise(med_delay = median(dep_delay, na.rm=TRUE)) %>% 
  arrange(desc(carrier))

median_delays_by_carrier_EWR
```

**Advanced**: But this is a little more elegant: using the `name` variable in the `airlines`
data set instead of `carrier` codes.

```{r, message=FALSE, echo=TRUE}
flights %>% 
  # join the flights to airlines data sets here!
  left_join(airlines, by="carrier") %>% 
  filter(origin == "EWR") %>% 
  group_by(name) %>% 
  summarise(med_delay = median(dep_delay, na.rm=TRUE)) %>% 
  arrange(desc(name))
```



#### d)

Name a graphic that would best show all the information contained in the
tables in part b)/c).

**Solution**: This gets the job done:

```{r, message=FALSE, echo=TRUE, warning=FALSE, fig.width=16/2, fig.height=9/2}
EWR_flights <- flights %>% 
  filter(origin == "EWR")

ggplot(data=EWR_flights, aes(x=carrier, y=dep_delay)) +
  geom_boxplot()
```

**Advanced**: As we said in the **advanced** part of Question 2,
`coord_cartesian(ylim=c(a,b))` will yield very different behavior than
`ylim(c(a,b))`. Why? Because if we clip points, we are going to change what
points going into the plots, and hence what the boxplot looks like!

```{r, echo=TRUE, message=FALSE, echo=TRUE, warning=FALSE, fig.width=16/2, fig.height=9/2}
ggplot(data=EWR_flights, aes(x=carrier, y=dep_delay)) +
  geom_boxplot() +
  ylim(c(-10, 10))
ggplot(data=EWR_flights, aes(x=carrier, y=dep_delay)) +
  geom_boxplot() +
  coord_cartesian(ylim=c(-10, 10))
```




#### e)

Write the rough pseudocode that will tabulate the mean humidity level 
recorded for all flights leaving New York City in July 2013.

**Solution**: Recall the image:

<img src="https://rudeboybert.github.io/MATH116/assets/figure/relational-nycflights.png" alt="Drawing" style="width: 600px;"/>

To match a flight to weather, you need to join by `year` AND `month` AND `day`
AND `hour` AND the airport of `origin`. (There was also a variable `time_hour`,
but for some reason it gave me errors). Also, note we don't need to `group_by`
anything! Just one overall mean!

```{r, echo=FALSE, message=FALSE, echo=TRUE,  warning=FALSE,  fig.width=16/2, fig.height=9/2}
flights %>% 
  filter(month==7) %>% 
  left_join(weather, by=c("year", "month", "day", "hour", "origin")) %>% 
  summarise(mean_humid = mean(humid, na.rm=TRUE))
```






## Question 4: Unisex Names... Revisited

**Question**: Compare the "unisexiness" of Casey vs Riley between 1950 and 2014.


#### Manipulating the Data

The tricky part here is using and/or statements. Here we want all rows where

* `name` is Casey **OR** Riley
* `year` is greater than or equal to 1950 **AND** less than or equal to 2014.

These principles of **boolean logic** hold for ALL programming languages.

```{r, echo=FALSE, message=FALSE, echo=TRUE, fig.width=16/2, fig.height=9/2}
library(babynames)
casey_and_riley <- babynames %>% 
  filter(name == "Casey" | name == "Riley") %>% 
  filter(year >= 1950 & year <= 2014)
```


#### Plotting the Comparison

There are two ways we can use `col` and `facet_wrap` to compare both the `sex`
and `name` variables.

```{r, echo=FALSE, message=FALSE, echo=TRUE, fig.width=16/2, fig.height=9/2}
ggplot(data=casey_and_riley, aes(x=year, y=prop, col=name)) +
  geom_line() +
  facet_wrap(~sex)
ggplot(data=casey_and_riley, aes(x=year, y=prop, col=sex)) +
  geom_line() +
  facet_wrap(~name)
```

While both do technically show the same information, I argue the latter is
better, as it better compares the male/female proportion of each name
head-to-head, as opposed to Casey/Riley proportions for each sex.




